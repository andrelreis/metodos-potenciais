'''
This code presents an approach for implementing the gravitational field
produced by a polygonal prism by using the analytical formulas of
Plouff (1976).

References
* Plouff, D. , 1976, Gravity and magnetic fields of polygonal prisms and
    applications to magnetic terrain corrections, Geophysics,
    41(4), 727-741. https://doi.org/10.1190/1.1440645

'''

import numpy as np
from numba import njit

############ Utils constants #########################
#: The gravitational constant in m^3 kg^{-1} s^{-1}
GRAVITATIONAL_CONST = 0.00000000006673

#: The magnetic permeability of free space in Henry*m^{-1}
MAGNETIC_PERM = 0.000001256

########### Modifying log to avoid zero division
@njit
def safe_log(x):
    """
    Modified log to return 0 for log(0).
    The limits in the formula terms tend to 0.
    """
    if np.abs(x) < 1e-10:
        result = 0
    else:
        result = np.log(x)
    return result


########## Functions for calculating all fields (gravity, gravity_gradient and magnetic field)
def gravitational(coordinates,polygons,thicknesses,density,field):
    """
    Computing the gravitational field generated by a polygonal prism.
    """

    kernels = {
        "gz": kernel_gz
    }

    # Checking input field
    if field not in kernels:
        raise ValueError(
            "Gravitational field {} not recognized".format(field)
        )

    # Checking input parameters
    if coordinates.ndim != 2:
        raise ValueError(
            "coordinates ndim ({}) ".format(coordinates.ndim)
            + "not equal to 2"
        )
    if coordinates.shape[0] != 3:
        raise ValueError(
            "Number of lines in coordinates ({}) ".format(coordinates.shape[0])
            + "not equal to 3"
        )
    
    if type(polygons) != list:
        raise ValueError(
            "Input polygons ({}) not recognized".format(a)
        )
    
    if thicknesses.ndim != 2:
        raise ValueError(
            "Thicknesses ndim ({}) ".format(thicknesses.ndim)
            + "not equal to 2"
        )

    if thicknesses.shape[1] != 2:
        raise ValueError(
            "Number of columns in thicknesses ({})".format(thicknesses.shape[1])
            + "not equal to 2"
        )

    if thicknesses.shape[0] != len(polygons):
        raise ValueError(
            "Number of polygons ({}) and thicknesses ({}) are different".format(len(polygons),thicknesses.shape[0])
        )
    
    if density.ndim != 1:
        raise ValueError(
            "density ndim ({}) ".format(density.ndim)
            + "not equal to 1"
        )

    if thicknesses.shape[0] != density.shape[0]:
        raise ValueError(
            "Number of polygons ({}) and density ({}) are different".format(thicknesses.shape[0],density.shape[0])
        )

    # Create the array to store the result
    result = np.zeros(coordinates[0].size, dtype="float64")

    # Compute gravitational field
    jit_gravitational(coordinates,polygons,thicknesses,density,kernels[field],result)
    result *= GRAVITATIONAL_CONST
    # Convert from m/s^2 to mGal
    if field in ["gz"]:
        result *= 1e5
    return result


def gravity_gradient(coordinates,polygons,thicknesses,density,field):
    """
    Computing the gravity gradient field generated by a polygonal prism.
    """

    kernels = {
        "gxx": kernel_xx,
        "gxy": kernel_xy,
        "gxz": kernel_xz,
        "gyy": kernel_yy,
        "gyz": kernel_yz,
        "gzz": kernel_zz
    }

    # Checking input field
    if field not in kernels:
        raise ValueError(
            "Gravitational field {} not recognized".format(field)
        )

    # Checking input parameters
    if coordinates.ndim != 2:
        raise ValueError(
            "coordinates ndim ({}) ".format(coordinates.ndim)
            + "not equal to 2"
        )
    if coordinates.shape[0] != 3:
        raise ValueError(
            "Number of lines in coordinates ({}) ".format(coordinates.shape[0])
            + "not equal to 3"
        )
    
    if type(polygons) != list:
        raise ValueError(
            "Input polygons ({}) not recognized".format(a)
        )
    
    if thicknesses.ndim != 2:
        raise ValueError(
            "Thicknesses ndim ({}) ".format(thicknesses.ndim)
            + "not equal to 2"
        )

    if thicknesses.shape[1] != 2:
        raise ValueError(
            "Number of columns in thicknesses ({})".format(thicknesses.shape[1])
            + "not equal to 2"
        )

    if thicknesses.shape[0] != len(polygons):
        raise ValueError(
            "Number of polygons ({}) and thicknesses ({}) are different".format(len(polygons),thicknesses.shape[0])
        )
    
    if density.ndim != 1:
        raise ValueError(
            "density ndim ({}) ".format(density.ndim)
            + "not equal to 1"
        )

    if thicknesses.shape[0] != density.shape[0]:
        raise ValueError(
            "Number of polygons ({}) and density ({}) are different".format(thicknesses.shape[0],density.shape[0])
        )

    # Create the array to store the result
    result = np.zeros(coordinates[0].size, dtype="float64")

    # Compute gravitational field
    jit_gravitational(coordinates,polygons,thicknesses,density,kernels[field],result)
    result *= GRAVITATIONAL_CONST
    # Convert from SI to eotvos
    if field in ["gxx","gxy","gxz","gyy","gyz"]:
        result *= 1e9
    return result


def magnetics(coordinates,polygons,thicknesses,intensities,directions,field):
    """
    Computing the magnetic field generated by a polygonal prism.
    """

    kernels = {
        "bz": kernel_bz,
        "bx": kernel_bx,
        "by": kernel_by
    }

    # Checking input field
    if field not in kernels:
        raise ValueError(
            "Magnetic field {} not recognized".format(field)
        )

    # Checking input parameters
    if coordinates.ndim != 2:
        raise ValueError(
            "coordinates ndim ({}) ".format(coordinates.ndim)
            + "not equal to 2"
        )
    if coordinates.shape[0] != 3:
        raise ValueError(
            "Number of lines in coordinates ({}) ".format(coordinates.shape[0])
            + "not equal to 3"
        )
    
    if type(polygons) != list:
        raise ValueError(
            "Input polygons ({}) not recognized".format(a)
        )
    
    if thicknesses.ndim != 2:
        raise ValueError(
            "Thicknesses ndim ({}) ".format(thicknesses.ndim)
            + "not equal to 2"
        )

    if thicknesses.shape[1] != 2:
        raise ValueError(
            "Number of columns in thicknesses ({})".format(thicknesses.shape[1])
            + "not equal to 2"
        )

    if thicknesses.shape[0] != len(polygons):
        raise ValueError(
            "Number of polygons ({}) and thicknesses ({}) are different".format(len(polygons),thicknesses.shape[0])
        )
    
    if intensities.ndim != 1:
        raise ValueError(
            "density ndim ({}) ".format(intensities.ndim)
            + "not equal to 1"
        )

    if thicknesses.shape[0] != intensities.shape[0]:
        raise ValueError(
            "Number of polygons ({}) and intensities ({}) are different".format(thicknesses.shape[0],intensities.shape[0])
        )

    # Create the array to store the result
    result = np.zeros(coordinates[0].size, dtype="float64")

    # Compute gravitational field
    jit_magnetic(coordinates,polygons,thicknesses,intensities,directions,kernels[field],result)
    result *= (MAGNETIC_PERM/(4*np.pi))
    # Convert from T to nanoTesla
    if field in ["bz","bx","by"]:
        result *= 1e9
    return result



######## Functions for computing field at the observation points
@njit
def jit_gravitational(coordinates,polygons,thicknesses,density,kernel,out):
    """
    Compute gravitational field at the observation points
    """
    # Iterate over coordinates
    for l in range(coordinates[0].size):
        # Iterate over polygons
        for m in range(len(polygons)):
            # Iterate over polygons vertices
            nverts = polygons[m].size//2
            for i in range(nverts-1):
                Y1 = polygons[m][0,i] - coordinates[0,l]
                Y2 = polygons[m][0,i+1] - coordinates[0,l]
                X1 = polygons[m][1,i] - coordinates[1,l]
                X2 = polygons[m][1,i+1] - coordinates[1,l]
                Z1 = thicknesses[m,0] - coordinates[2,l]
                Z2 = thicknesses[m,1] - coordinates[2,l]
                out[l] += (density[m] * kernel(Y1,Y2,X1,X2,Z1,Z2))

@njit
def jit_magnetic(coordinates,polygons,thicknesses,intensities,directions,kernel,out):
    """
    Compute magnetic field at the observation points
    """
    # Iterate over coordinates
    for l in range(coordinates[0].size):
        # Iterate over polygons
        for m in range(len(polygons)):
            # Iterate over polygons vertices
            nverts = polygons[m].size//2
            for i in range(nverts-1):
                Y1 = polygons[m][0,i] - coordinates[0,l]
                Y2 = polygons[m][0,i+1] - coordinates[0,l]
                X1 = polygons[m][1,i] - coordinates[1,l]
                X2 = polygons[m][1,i+1] - coordinates[1,l]
                Z1 = thicknesses[m,0] - coordinates[2,l]
                Z2 = thicknesses[m,1] - coordinates[2,l]
                out[l] += (intensities[m] * kernel(Y1,Y2,X1,X2,Z1,Z2,directions[m]))

                
############ Computing kernels for all fields
@njit
def kernel_gz(Y1,Y2,X1,X2,Z1,Z2):
    """
    Kernel for downward component of gravitational acceleration of a polygonal prism
    """
    dummy = 1e-10
    Z1_sqr = Z1**2
    Z2_sqr = Z2**2
    p = X1*Y2 - X2*Y1
    p_sqr = p**2
    Q1 = (Y2 - Y1)*Y1 + (X2 - X1)*X1
    Q2 = (Y2 - Y1)*Y2 + (X2 - X1)*X2
    A1 = X1**2 + Y1**2
    A2 = X2**2 + Y2**2
    R11 = np.sqrt(A1 + Z1_sqr)
    R12 = np.sqrt(A2 + Z1_sqr)
    R21 = np.sqrt(A1 + Z2_sqr)
    R22 = np.sqrt(A2 + Z2_sqr)
    A1 = np.sqrt(A1)
    A2 = np.sqrt(A2)
    B1 = np.sqrt(Q1**2 + p_sqr)
    B2 = np.sqrt(Q2**2 + p_sqr)
    E11 = R11*B1
    E12 = R12*B2
    E21 = R21*B1
    E22 = R22*B2
    C1 = Q1*A1
    C2 = Q2*A2
    
    T1 = (Z2 - Z1)*(np.arctan2(Q2,p) - np.arctan2(Q1,p))
    T2 = Z2*(np.arctan2(Z2*Q1, R21*p) - np.arctan2(Z2*Q2,R22*p))
    T3 = Z1*(np.arctan2(Z1*Q2, R12*p) - np.arctan2(Z1*Q1,R11*p))
    
    T4 = (0.5*p*A1/B1)*safe_log(
        ((E11 - C1)*(E21 + C1))/((E11 + C1)*(E21 - C1)))
    T5 = (0.5*p*A2/B2)*safe_log(
        ((E22 - C2)*(E12 + C2))/((E22 + C2)*(E12 - C2)))
    kernel = T1 + T2 + T3 + T4 + T5
    return kernel

@njit
def kernel_xx(Y1,Y2,X1,X2,Z1,Z2):
    """
    Kernel xx for second derivative of the potential generated by a polygon
    """
    kernel = 0 
    dummy = 1e-10
    Z1_sqr = Z1*Z1
    Z2_sqr = Z2*Z2
    deltax = X2 - X1 + dummy
    deltay = Y2 - Y1 + dummy
    n = deltax/deltay
    g = X1 - Y1*n
    dist = np.sqrt(deltax*deltax + deltay*deltay)
    cross = X1*Y2 - X2*Y1
    p = cross/dist + dummy
    d1 = (deltax*X1 + deltay*Y1)/dist + dummy
    d2 = (deltax*X2 + deltay*Y2)/dist + dummy
    vert1_sqr = X1*X1 + Y1*Y1
    vert2_sqr = X2*X2 + Y2*Y2
    R11 = np.sqrt(vert1_sqr + Z1_sqr)
    R12 = np.sqrt(vert1_sqr + Z2_sqr)
    R21 = np.sqrt(vert2_sqr + Z1_sqr)
    R22 = np.sqrt(vert2_sqr + Z2_sqr)
    atan_diff_d2 = np.arctan2(Z2*d2, p*R22) - np.arctan2(Z1*d2, p*R21)
    atan_diff_d1 = np.arctan2(Z2*d1, p*R12) - np.arctan2(Z1*d1, p*R11)
    tmp = g*Y2*atan_diff_d2/(p*d2) + n*p*atan_diff_d2/(d2)
    tmp -= g*Y1*atan_diff_d1/(p*d1) + n*p*atan_diff_d1/(d1)
    tmp += n*safe_log(
            (Z2 + R12)*(Z1 + R21)/((Z1 + R11)*(Z2 + R22)))
    tmp *= -1/(1 + n*n)
    kernel += tmp
    return kernel
    
@njit
def kernel_xy(Y1,Y2,X1,X2,Z1,Z2):
    """
    Kernel xy for second derivative of the potential generated by a polygon
    """
    kernel = 0
    dummy = 1e-10
    Z1_sqr = Z1*Z1
    Z2_sqr = Z2*Z2
    deltax = X2 - X1 + dummy
    deltay = Y2 - Y1 + dummy
    n = deltax/deltay
    g = X1 - Y1*n
    g_sqr = g*g
    dist = np.sqrt(deltax*deltax + deltay*deltay)
    cross = X1*Y2 - X2*Y1
    p = cross/dist + dummy
    d1 = (deltax*X1 + deltay*Y1)/dist + dummy
    d2 = (deltax*X2 + deltay*Y2)/dist + dummy
    vert1_sqr = X1*X1 + Y1*Y1
    vert2_sqr = X2*X2 + Y2*Y2
    R11 = np.sqrt(vert1_sqr + Z1_sqr)
    R12 = np.sqrt(vert1_sqr + Z2_sqr)
    R21 = np.sqrt(vert2_sqr + Z1_sqr)
    R22 = np.sqrt(vert2_sqr + Z2_sqr)
    atan_diff_d2 = np.arctan2(Z2*d2, p*R22) - np.arctan2(Z1*d2, p*R21)
    atan_diff_d1 = np.arctan2(Z2*d1, p*R12) - np.arctan2(Z1*d1, p*R11)
    tmp = (g_sqr + g*n*Y2)*atan_diff_d2/(p*d2) - p*atan_diff_d2/d2
    tmp -= (g_sqr + g*n*Y1)*atan_diff_d1/(p*d1) - p*atan_diff_d1/d1
    tmp += safe_log(
            (Z2 + R22)*(Z1 + R11)/((Z1 + R21)*(Z2 + R12)))
    tmp *= 1/(1 + n*n)
    kernel += tmp
    return kernel

@njit
def kernel_xz(Y1,Y2,X1,X2,Z1,Z2):
    """
    Kernel xz for second derivative of the potential generated by a polygon
    """
    kernel = 0
    dummy = 1e-10
    Z1_sqr = Z1*Z1
    Z2_sqr = Z2*Z2
    deltax = X2 - X1 + dummy
    deltay = Y2 - Y1 + dummy
    n = deltax/deltay
    n_sqr_p1 = n*n + 1
    g = X1 - Y1*n
    ng = n*g
    dist = np.sqrt(deltax*deltax + deltay*deltay)
    d1 = (deltax*X1 + deltay*Y1)/dist + dummy
    d2 = (deltax*X2 + deltay*Y2)/dist + dummy
    vert1_sqr = X1*X1 + Y1*Y1
    vert2_sqr = X2*X2 + Y2*Y2
    R11 = np.sqrt(vert1_sqr + Z1_sqr)
    R12 = np.sqrt(vert1_sqr + Z2_sqr)
    R21 = np.sqrt(vert2_sqr + Z1_sqr)
    R22 = np.sqrt(vert2_sqr + Z2_sqr)
    log_r22 = safe_log((R22 - d2)/(R22 + d2))
    log_r21 = safe_log((R21 - d2)/(R21 + d2))
    log_r12 = safe_log((R12 - d1)/(R12 + d1))
    log_r11 = safe_log((R11 - d1)/(R11 + d1))
    log_diff_d1 = (0.5/d1)*(log_r12 - log_r11)
    log_diff_d2 = (0.5/d2)*(log_r22 - log_r21)
    tmp = (Y2*n_sqr_p1 + ng)*log_diff_d2
    tmp -= (Y1*n_sqr_p1 + ng)*log_diff_d1
    tmp *= -1/n_sqr_p1
    kernel += tmp
    return kernel

@njit
def kernel_yy(Y1,Y2,X1,X2,Z1,Z2):
    """
    Kernel yy for second derivative of the potential generated by a polygon
    """
    kernel = 0
    dummy = 1e-10
    Z1_sqr = Z1*Z1
    Z2_sqr = Z2*Z2
    deltax = X2 - X1 + dummy
    deltay = Y2 - Y1 + dummy
    m = deltay/deltax
    c = Y1 - X1*m
    dist = np.sqrt(deltax*deltax + deltay*deltay)
    cross = X1*Y2 - X2*Y1
    p = cross/dist + dummy
    d1 = (deltax*X1 + deltay*Y1)/dist + dummy
    d2 = (deltax*X2 + deltay*Y2)/dist + dummy
    vert1_sqr = X1*X1 + Y1*Y1
    vert2_sqr = X2*X2 + Y2*Y2
    R11 = np.sqrt(vert1_sqr + Z1_sqr)
    R12 = np.sqrt(vert1_sqr + Z2_sqr)
    R21 = np.sqrt(vert2_sqr + Z1_sqr)
    R22 = np.sqrt(vert2_sqr + Z2_sqr)
    atan_diff_d2 = np.arctan2(Z2*d2, p*R22) - np.arctan2(Z1*d2, p*R21)
    atan_diff_d1 = np.arctan2(Z2*d1, p*R12) - np.arctan2(Z1*d1, p*R11)
    tmp = c*X2*atan_diff_d2/(p*d2) + m*p*atan_diff_d2/d2
    tmp -= c*X1*atan_diff_d1/(p*d1) + m*p*atan_diff_d1/d1
    tmp += m*safe_log(
            (Z2 + R12)*(Z1 + R21)/((Z2 + R22)*(Z1 + R11)))
    tmp *= 1/(1 + m*m)
    kernel += tmp
    return kernel

@njit
def kernel_yz(Y1,Y2,X1,X2,Z1,Z2):
    """
    Kernel yz for second derivative of the potential generated by a polygon
    """
    kernel = 0
    dummy = 1e-10
    Z1_sqr = Z1*Z1
    Z2_sqr = Z2*Z2
    deltax = X2 - X1 + dummy
    deltay = Y2 - Y1 + dummy
    m = deltay/deltax
    m_sqr_p1 = m*m + 1
    c = Y1 - X1*m
    cm = c*m
    dist = np.sqrt(deltax*deltax + deltay*deltay)
    d1 = (deltax*X1 + deltay*Y1)/dist + dummy
    d2 = (deltax*X2 + deltay*Y2)/dist + dummy
    vert1_sqr = X1*X1 + Y1*Y1
    vert2_sqr = X2*X2 + Y2*Y2
    R11 = np.sqrt(vert1_sqr + Z1_sqr)
    R12 = np.sqrt(vert1_sqr + Z2_sqr)
    R21 = np.sqrt(vert2_sqr + Z1_sqr)
    R22 = np.sqrt(vert2_sqr + Z2_sqr)
        
    log_r11 = safe_log((R11 - d1)/(R11 + d1))
    log_r12 = safe_log((R12 - d1)/(R12 + d1))
    log_r21 = safe_log((R21 - d2)/(R21 + d2))
    log_r22 = safe_log((R22 - d2)/(R22 + d2))
    tmp = (X2*m_sqr_p1 + cm)*(0.5/d2)*(log_r22 - log_r21)
    tmp -= (X1*m_sqr_p1 + cm)*(0.5/d1)*(log_r12 - log_r11)
    tmp *= 1/m_sqr_p1
    kernel += tmp
    return kernel

@njit
def kernel_zz(Y1,Y2,X1,X2,Z1,Z2):
    """
    Kernel zz for second derivative of the potential generated by a polygon
    """
    kernel = 0
    dummy = 1e-10
    Z1_sqr = Z1*Z1
    Z2_sqr = Z2*Z2
    deltax = X2 - X1
    deltay = Y2 - Y1
    dist = np.sqrt(deltax*deltax + deltay*deltay) + dummy
    cross = X1*Y2 - X2*Y1
    p = cross/dist
    d1 = (deltax*X1 + deltay*Y1)/dist
    d2 = (deltax*X2 + deltay*Y2)/dist
    vert1_sqr = X1*X1 + Y1*Y1
    vert2_sqr = X2*X2 + Y2*Y2
    R11 = np.sqrt(vert1_sqr + Z1_sqr)
    R12 = np.sqrt(vert1_sqr + Z2_sqr)
    R21 = np.sqrt(vert2_sqr + Z1_sqr)
    R22 = np.sqrt(vert2_sqr + Z2_sqr)
    kernel += (np.arctan2(Z2*d2, p*R22) - np.arctan2(Z1*d2, p*R21) -
                   np.arctan2(Z2*d1, p*R12) + np.arctan2(Z1*d1, p*R11))
    return kernel

@njit
def kernel_bz(Y1,Y2,X1,X2,Z1,Z2,direction):
    """
    Vertical component of the magnetic field generated by a polygon
    """
    
    inclination,declination = direction
    jx = np.cos(np.deg2rad(inclination))*np.cos(np.deg2rad(declination))
    jy = np.cos(np.deg2rad(inclination))*np.sin(np.deg2rad(declination))
    jz = np.sin(np.deg2rad(inclination))

    kernel = jx*kernel_xz(Y1,Y2,X1,X2,Z1,Z2) + jy*kernel_yz(Y1,Y2,X1,X2,Z1,Z2) + jz*kernel_zz(Y1,Y2,X1,X2,Z1,Z2)
    return kernel

@njit
def kernel_bx(Y1,Y2,X1,X2,Z1,Z2,direction):
    """
    Computing x component of the magnetic field generated by a polygon
    """    
    inclination,declination = direction
    jx = np.cos(np.deg2rad(inclination))*np.cos(np.deg2rad(declination))
    jy = np.cos(np.deg2rad(inclination))*np.sin(np.deg2rad(declination))
    jz = np.sin(np.deg2rad(inclination))

    kernel = jx*kernel_xx(Y1,Y2,X1,X2,Z1,Z2) + jy*kernel_xy(Y1,Y2,X1,X2,Z1,Z2) + jz*kernel_xz(Y1,Y2,X1,X2,Z1,Z2)
    return kernel

@njit
def kernel_by(Y1,Y2,X1,X2,Z1,Z2,direction):
    """
    Computing y component of the magnetic field generated by a polygon
    """
    inclination,declination = direction
    jx = np.cos(np.deg2rad(inclination))*np.cos(np.deg2rad(declination))
    jy = np.cos(np.deg2rad(inclination))*np.sin(np.deg2rad(declination))
    jz = np.sin(np.deg2rad(inclination))

    kernel = jx*kernel_xy(Y1,Y2,X1,X2,Z1,Z2) + jy*kernel_yy(Y1,Y2,X1,X2,Z1,Z2) + jz*kernel_yz(Y1,Y2,X1,X2,Z1,Z2)
    return kernel
    
    