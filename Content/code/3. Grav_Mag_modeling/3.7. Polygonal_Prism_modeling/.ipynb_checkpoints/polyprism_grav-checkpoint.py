'''
This code presents an approach for implementing the gravitational field
produced by a polygonal prism by using the analytical formulas of
Plouff (1976). It also makes use of the modified arctangent function proposed
by Fukushima (2020, eq. 72).

References
* Plouff, D. , 1976, Gravity and magnetic fields of polygonal prisms and
    applications to magnetic terrain corrections, Geophysics,
    41(4), 727-741. https://doi.org/10.1190/1.1440645

* Fukushima, T. (2020). Speed and accuracy improvements in standard algorithm
    for prismatic gravitational field. Geophysical Journal International,
    222(3), 1898â€“1908. http://doi.org/10.1093/gji/ggaa240

'''

import numpy as np
from numba import jit

#: The gravitational constant in m^3 kg^{-1} s^{-1}
GRAVITATIONAL_CONST = 0.00000000006673

@jit(nopython=True)
def safe_atan2(y, x):
    """
    Principal value of the arctangent expressed as a two variable function

    This modification has to be made to the arctangent function so the
    gravitational field of the prism satisfies the Poisson's equation.
    Therefore, it guarantees that the fields satisfies the symmetry properties
    of the prism. This modified function has been defined according to
    Fukushima (2020, eq. 72).
    """
    if x != 0:
        result = np.arctan(y / x)
    else:
        if y > 0:
            result = np.pi / 2
        elif y < 0:
            result = -np.pi / 2
        else:
            result = 0
    return result

@jit(nopython=True)
def safe_log(x):
    """
    Modified log to return 0 for log(0).
    The limits in the formula terms tend to 0.
    """
    if np.abs(x) < 1e-10:
        result = 0
    else:
        result = np.log(x)
    return result

def gravitational(coordinates,vertices,top,bottom,density,field):
    """
    Computing the gravitational field generated by a polygonal prism.
    """

    kernels = {"g_z": kernel_z}

    # Checking input field
    if field not in kernels:
        raise ValueError("Gravitational field {} not recognized".format(field))

    # Checking input parameters
    if coordinates.ndim != 2:
        raise ValueError(
            "coordinates ndim ({}) ".format(coordinates.ndim)
            + "not equal to 2"
        )
    if coordinates.shape[0] != 3:
        raise ValueError(
            "Number of lines in coordinates ({}) ".format(coordinates.shape[0])
            + "not equal to 3"
        )
    if vertices.ndim != 2:
        raise ValueError(
            "prisms ndim ({}) ".format(vertices.ndim)
            + "not equal to 2"
        )

    if density.ndim != 1:
        raise ValueError(
            "density ndim ({}) ".format(density.ndim)
            + "not equal to 1"
        )

    if top.ndim != 1:
        raise ValueError(
            "top ndim ({}) ".format(top.ndim)
            + "not equal to 1"
        )

    if bottom.ndim != 1:
        raise ValueError(
            "bottom ndim ({}) ".format(bottom.ndim)
            + "not equal to 1"
        )

    if density.size != (vertices.shape[0] // 2):
        raise ValueError(
            "Number of elements in density ({}) ".format(density.size)
            + "mismatch the number of prisms ({})".format(vertices.shape[0]//2)
        )

    if top.size != (vertices.shape[0] // 2):
        raise ValueError(
            "Number of elements in top ({}) ".format(top.size)
            + "mismatch the number of prisms ({})".format(vertices.shape[0]//2)
        )

    if bottom.size != (vertices.shape[0] // 2):
        raise ValueError(
            "Number of elements in bottom ({}) ".format(density.size)
            + "mismatch the number of prisms ({})".format(vertices.shape[0]//2)
        )

    # Create the array to store the result
    result = np.zeros(coordinates[0].size, dtype="float64")

    # Compute gravitational field
    jit_gravitational(coordinates, vertices, top, bottom, density, kernels[field], result)
    result *= GRAVITATIONAL_CONST
    # Convert from m/s^2 to mGal
    if field in ["g_z"]:
        result *= 1e5
    return result

@jit(nopython=True)
def jit_gravitational(coordinates,prisms,density,kernel,out):
    """
    Compute gravitational field at the observation points
    """
    nprisms = prisms.shape[0] // 2
    nverts = prisms.shape[1]
    # Iterate over coordinates
    for l in range(coordinates[0].size):
        # Iterate over prisms
        for m in range(nprisms):
            # Iterate over prisms vertices
            for i in range(nverts):
                Y1 = prisms[2*m,i] - coordinates[0,l]
                X1 = prisms[2*m+1,i] - coordinates[1,l]
                Y2 = prisms[2*m,i+1] - coordinates[0,l]
                X2 = prisms[2*m+1,i+1] - coordinates[1,l]
                Z1 = top[m] - coordinates[2,l]
                Z2 = bottom[m] - coordinates[2,l]
                out[l] += (density[m] * kernel(Y1,X1,Y2,X2,Z1,Z2)


####################### PAREI AQUI ##################################
#@jit(nopython=True)
#def kernel_z(Y, X, Z):
#    """
#    Kernel for downward component of gravitational acceleration of a prism
#    """
#    radius = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
#    kernel = - (Y * safe_log(X + radius) +
#                X * safe_log(Y + radius) -
#                Z * safe_atan2(Y * X, Z * radius))
#    return kernel
