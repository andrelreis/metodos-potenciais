'''
This code presents an approach for implementing the gravitational field
produced by a polygonal prism by using the analytical formulas of
Plouff (1976). It also makes use of the modified arctangent function proposed
by Fukushima (2020, eq. 72).

References
* Plouff, D. , 1976, Gravity and magnetic fields of polygonal prisms and
    applications to magnetic terrain corrections, Geophysics,
    41(4), 727-741. https://doi.org/10.1190/1.1440645

* Fukushima, T. (2020). Speed and accuracy improvements in standard algorithm
    for prismatic gravitational field. Geophysical Journal International,
    222(3), 1898â€“1908. http://doi.org/10.1093/gji/ggaa240

'''

import numpy as np
from numba import njit

#: The gravitational constant in m^3 kg^{-1} s^{-1}
GRAVITATIONAL_CONST = 0.00000000006673

@njit
def safe_atan2(y, x):
    """
    Principal value of the arctangent expressed as a two variable function

    This modification has to be made to the arctangent function so the
    gravitational field of the prism satisfies the Poisson's equation.
    Therefore, it guarantees that the fields satisfies the symmetry properties
    of the prism. This modified function has been defined according to
    Fukushima (2020, eq. 72).
    """
    if x != 0:
        result = np.arctan(y / x)
    else:
        if y > 0:
            result = np.pi / 2
        elif y < 0:
            result = -np.pi / 2
        else:
            result = 0
    return result

@njit
def safe_log(x):
    """
    Modified log to return 0 for log(0).
    The limits in the formula terms tend to 0.
    """
    if np.abs(x) < 1e-10:
        result = 0
    else:
        result = np.log(x)
    return result


def gradient(coordinates,polygons,thicknesses,density,field):
    """
    Computing the gravitational field generated by a polygonal prism.
    """

    kernels = {
        "gxx": kernel_xx,
        "gxy": kernel_xy,
        "gxz": kernel_xz,
        "gyy": kernel_yy,
        "gyz": kernel_yz,
        "gzz": kernel_zz
    }

    # Checking input field
    if field not in kernels:
        raise ValueError(
            "Gravitational field {} not recognized".format(field)
        )

    # Checking input parameters
    if coordinates.ndim != 2:
        raise ValueError(
            "coordinates ndim ({}) ".format(coordinates.ndim)
            + "not equal to 2"
        )
    if coordinates.shape[0] != 3:
        raise ValueError(
            "Number of lines in coordinates ({}) ".format(coordinates.shape[0])
            + "not equal to 3"
        )
    
    if type(polygons) != list:
        raise ValueError(
            "Input polygons ({}) not recognized".format(a)
        )
    
    if thicknesses.ndim != 2:
        raise ValueError(
            "Thicknesses ndim ({}) ".format(thicknesses.ndim)
            + "not equal to 2"
        )

    if thicknesses.shape[1] != 2:
        raise ValueError(
            "Number of columns in thicknesses ({})".format(thicknesses.shape[1])
            + "not equal to 2"
        )

    if thicknesses.shape[0] != len(polygons):
        raise ValueError(
            "Number of polygons ({}) and thicknesses ({}) are different".format(len(polygons),thicknesses.shape[0])
        )
    
    if density.ndim != 1:
        raise ValueError(
            "density ndim ({}) ".format(density.ndim)
            + "not equal to 1"
        )

    if thicknesses.shape[0] != density.shape[0]:
        raise ValueError(
            "Number of polygons ({}) and density ({}) are different".format(thicknesses.shape[0],density.shape[0])
        )

    # Create the array to store the result
    result = np.zeros(coordinates[0].size, dtype="float64")

    # Compute gravitational field
    jit_gradient(coordinates,polygons,thicknesses,density,kernels[field],result)
    result *= GRAVITATIONAL_CONST
    # Convert from m/s^2 to mGal
    if field in ["gxx","gxy","gxz","gyy","gyz"]:
        result *= 1e9
    return result

@njit
def jit_gradient(coordinates,polygons,thicknesses,density,kernel,out):
    """
    Compute the gravity gradient field at the observation points
    """
    # Iterate over coordinates
    for l in range(coordinates[0].size):
        # Iterate over polygons
        for m in range(len(polygons)):
            # Iterate over polygons vertices
            nverts = polygons[m].size//2
            for i in range(nverts-1):
                Y1 = polygons[m][0,i] - coordinates[0,l]
                Y2 = polygons[m][0,i+1] - coordinates[0,l]
                X1 = polygons[m][1,i] - coordinates[1,l]
                X2 = polygons[m][1,i+1] - coordinates[1,l]
                Z1 = thicknesses[m,0] - coordinates[2,l]
                Z2 = thicknesses[m,1] - coordinates[2,l]
                out[l] += (density[m] * kernel(Y1,Y2,X1,X2,Z1,Z2))


@njit
def kernel_xx(Y1,Y2,X1,X2,Z1,Z2):
    """
    Kernel xx for second derivative of the potential generated by a polygon
    """
    kernel = 0 
    dummy = 1e-10
    Z1_sqr = Z1*Z1
    Z2_sqr = Z2*Z2
    deltax = X2 - X1 + dummy
    deltay = Y2 - Y1 + dummy
    n = deltax/deltay
    g = X1 - Y1*n
    dist = np.sqrt(deltax*deltax + deltay*deltay)
    cross = X1*Y2 - X2*Y1
    p = cross/dist + dummy
    d1 = (deltax*X1 + deltay*Y1)/dist + dummy
    d2 = (deltax*X2 + deltay*Y2)/dist + dummy
    vert1_sqr = X1*X1 + Y1*Y1
    vert2_sqr = X2*X2 + Y2*Y2
    R11 = np.sqrt(vert1_sqr + Z1_sqr)
    R12 = np.sqrt(vert1_sqr + Z2_sqr)
    R21 = np.sqrt(vert2_sqr + Z1_sqr)
    R22 = np.sqrt(vert2_sqr + Z2_sqr)
    atan_diff_d2 = np.arctan2(Z2*d2, p*R22) - np.arctan2(Z1*d2, p*R21)
    atan_diff_d1 = np.arctan2(Z2*d1, p*R12) - np.arctan2(Z1*d1, p*R11)
    tmp = g*Y2*atan_diff_d2/(p*d2) + n*p*atan_diff_d2/(d2)
    tmp -= g*Y1*atan_diff_d1/(p*d1) + n*p*atan_diff_d1/(d1)
    tmp += n*np.log(
            (Z2 + R12)*(Z1 + R21)/((Z1 + R11)*(Z2 + R22) + dummy) + dummy)
    tmp *= -1/(1 + n*n)
    kernel += tmp
    return kernel
    
@njit
def kernel_xy(Y1,Y2,X1,X2,Z1,Z2):
    """
    Kernel xy for second derivative of the potential generated by a polygon
    """
    kernel = 0
    dummy = 1e-10
    Z1_sqr = Z1*Z1
    Z2_sqr = Z2*Z2
    deltax = X2 - X1 + dummy
    deltay = Y2 - Y1 + dummy
    n = deltax/deltay
    g = X1 - Y1*n
    g_sqr = g*g
    dist = np.sqrt(deltax*deltax + deltay*deltay)
    cross = X1*Y2 - X2*Y1
    p = cross/dist + dummy
    d1 = (deltax*X1 + deltay*Y1)/dist + dummy
    d2 = (deltax*X2 + deltay*Y2)/dist + dummy
    vert1_sqr = X1*X1 + Y1*Y1
    vert2_sqr = X2*X2 + Y2*Y2
    R11 = np.sqrt(vert1_sqr + Z1_sqr)
    R12 = np.sqrt(vert1_sqr + Z2_sqr)
    R21 = np.sqrt(vert2_sqr + Z1_sqr)
    R22 = np.sqrt(vert2_sqr + Z2_sqr)
    atan_diff_d2 = np.arctan2(Z2*d2, p*R22) - np.arctan2(Z1*d2, p*R21)
    atan_diff_d1 = np.arctan2(Z2*d1, p*R12) - np.arctan2(Z1*d1, p*R11)
    tmp = (g_sqr + g*n*Y2)*atan_diff_d2/(p*d2) - p*atan_diff_d2/d2
    tmp -= (g_sqr + g*n*Y1)*atan_diff_d1/(p*d1) - p*atan_diff_d1/d1
    tmp += np.log(
            (Z2 + R22)*(Z1 + R11)/((Z1 + R21)*(Z2 + R12) + dummy) + dummy)
    tmp *= 1/(1 + n*n)
    kernel += tmp
    return kernel

@njit
def kernel_xz(Y1,Y2,X1,X2,Z1,Z2):
    """
    Kernel xz for second derivative of the potential generated by a polygon
    """
    kernel = 0
    dummy = 1e-10
    Z1_sqr = Z1*Z1
    Z2_sqr = Z2*Z2
    deltax = X2 - X1 + dummy
    deltay = Y2 - Y1 + dummy
    n = deltax/deltay
    n_sqr_p1 = n*n + 1
    g = X1 - Y1*n
    ng = n*g
    dist = np.sqrt(deltax*deltax + deltay*deltay)
    d1 = (deltax*X1 + deltay*Y1)/dist + dummy
    d2 = (deltax*X2 + deltay*Y2)/dist + dummy
    vert1_sqr = X1*X1 + Y1*Y1
    vert2_sqr = X2*X2 + Y2*Y2
    R11 = np.sqrt(vert1_sqr + Z1_sqr)
    R12 = np.sqrt(vert1_sqr + Z2_sqr)
    R21 = np.sqrt(vert2_sqr + Z1_sqr)
    R22 = np.sqrt(vert2_sqr + Z2_sqr)
    log_r22 = np.log((R22 - d2)/(R22 + d2) + dummy)
    log_r21 = np.log((R21 - d2)/(R21 + d2) + dummy)
    log_r12 = np.log((R12 - d1)/(R12 + d1) + dummy)
    log_r11 = np.log((R11 - d1)/(R11 + d1) + dummy)
    log_diff_d1 = (0.5/d1)*(log_r12 - log_r11)
    log_diff_d2 = (0.5/d2)*(log_r22 - log_r21)
    tmp = (Y2*n_sqr_p1 + ng)*log_diff_d2
    tmp -= (Y1*n_sqr_p1 + ng)*log_diff_d1
    tmp *= -1/n_sqr_p1
    kernel += tmp
    return kernel

@njit
def kernel_yy(Y1,Y2,X1,X2,Z1,Z2):
    """
    Kernel yy for second derivative of the potential generated by a polygon
    """
    kernel = 0
    dummy = 1e-10
    Z1_sqr = Z1*Z1
    Z2_sqr = Z2*Z2
    deltax = X2 - X1 + dummy
    deltay = Y2 - Y1 + dummy
    m = deltay/deltax
    c = Y1 - X1*m
    dist = np.sqrt(deltax*deltax + deltay*deltay)
    cross = X1*Y2 - X2*Y1
    p = cross/dist + dummy
    d1 = (deltax*X1 + deltay*Y1)/dist + dummy
    d2 = (deltax*X2 + deltay*Y2)/dist + dummy
    vert1_sqr = X1*X1 + Y1*Y1
    vert2_sqr = X2*X2 + Y2*Y2
    R11 = np.sqrt(vert1_sqr + Z1_sqr)
    R12 = np.sqrt(vert1_sqr + Z2_sqr)
    R21 = np.sqrt(vert2_sqr + Z1_sqr)
    R22 = np.sqrt(vert2_sqr + Z2_sqr)
    atan_diff_d2 = np.arctan2(Z2*d2, p*R22) - np.arctan2(Z1*d2, p*R21)
    atan_diff_d1 = np.arctan2(Z2*d1, p*R12) - np.arctan2(Z1*d1, p*R11)
    tmp = c*X2*atan_diff_d2/(p*d2) + m*p*atan_diff_d2/d2
    tmp -= c*X1*atan_diff_d1/(p*d1) + m*p*atan_diff_d1/d1
    tmp += m*np.log(
            (Z2 + R12)*(Z1 + R21)/((Z2 + R22)*(Z1 + R11)) + dummy)
    tmp *= 1/(1 + m*m)
    kernel += tmp
    return kernel

@njit
def kernel_yz(Y1,Y2,X1,X2,Z1,Z2):
    """
    Kernel yz for second derivative of the potential generated by a polygon
    """
    kernel = 0
    dummy = 1e-10
    Z1_sqr = Z1*Z1
    Z2_sqr = Z2*Z2
    deltax = X2 - X1 + dummy
    deltay = Y2 - Y1 + dummy
    m = deltay/deltax
    m_sqr_p1 = m*m + 1
    c = Y1 - X1*m
    cm = c*m
    dist = np.sqrt(deltax*deltax + deltay*deltay)
    d1 = (deltax*X1 + deltay*Y1)/dist + dummy
    d2 = (deltax*X2 + deltay*Y2)/dist + dummy
    vert1_sqr = X1*X1 + Y1*Y1
    vert2_sqr = X2*X2 + Y2*Y2
    R11 = np.sqrt(vert1_sqr + Z1_sqr)
    R12 = np.sqrt(vert1_sqr + Z2_sqr)
    R21 = np.sqrt(vert2_sqr + Z1_sqr)
    R22 = np.sqrt(vert2_sqr + Z2_sqr)
        
    log_r11 = np.log((R11 - d1)/(R11 + d1) + dummy)
    log_r12 = np.log((R12 - d1)/(R12 + d1) + dummy)
    log_r21 = np.log((R21 - d2)/(R21 + d2) + dummy)
    log_r22 = np.log((R22 - d2)/(R22 + d2) + dummy)
    tmp = (X2*m_sqr_p1 + cm)*(0.5/d2)*(log_r22 - log_r21)
    tmp -= (X1*m_sqr_p1 + cm)*(0.5/d1)*(log_r12 - log_r11)
    tmp *= 1/m_sqr_p1
    kernel += tmp
    return kernel

@njit
def kernel_zz(Y1,Y2,X1,X2,Z1,Z2):
    """
    Kernel zz for second derivative of the potential generated by a polygon
    """
    kernel = 0
    dummy = 1e-10
    Z1_sqr = Z1*Z1
    Z2_sqr = Z2*Z2
    deltax = X2 - X1
    deltay = Y2 - Y1
    dist = np.sqrt(deltax*deltax + deltay*deltay) + dummy
    cross = X1*Y2 - X2*Y1
    p = cross/dist
    d1 = (deltax*X1 + deltay*Y1)/dist
    d2 = (deltax*X2 + deltay*Y2)/dist
    vert1_sqr = X1*X1 + Y1*Y1
    vert2_sqr = X2*X2 + Y2*Y2
    R11 = np.sqrt(vert1_sqr + Z1_sqr)
    R12 = np.sqrt(vert1_sqr + Z2_sqr)
    R21 = np.sqrt(vert2_sqr + Z1_sqr)
    R22 = np.sqrt(vert2_sqr + Z2_sqr)
    kernel += (np.arctan2(Z2*d2, p*R22) - np.arctan2(Z1*d2, p*R21) -
                   np.arctan2(Z2*d1, p*R12) + np.arctan2(Z1*d1, p*R11))
    return kernel
