'''
This code presents an approach for implementing the gravitational field
produced by a sphere by using the analytical formulas.

Reference: 
'''

import numpy as np
from numba import jit


#: The magnetic permeability of free space in Henry*m^{-1}
MAGNETIC_PERM = 0.000001256

def kernel(coordinates,spheres,field):
    """
    Computing the magnetic field effect generated by a sphere.
    """

    kernels = {"phi_xx": phi_xx,
               "phi_xy": phi_xy,
               "phi_xz": phi_xz,
               "phi_yy": phi_yy,
               "phi_yz": phi_yz,
               "phi_zz": phi_zz
               }

    # Checking input field
    if field not in kernels:
        raise ValueError("Magnetic field {} not recognized".format(field))

    # Checking input parameters
    if coordinates.ndim != 2:
        raise ValueError(
            "coordinates ndim ({}) ".format(coordinates.ndim)
            + "not equal to 2"
        )
    if coordinates.shape[0] != 3:
        raise ValueError(
            "Number of lines in coordinates ({}) ".format(coordinates.shape[0])
            + "not equal to 3"
        )
    if spheres.ndim != 2:
        raise ValueError(
            "prisms ndim ({}) ".format(spheres.ndim)
            + "not equal to 2"
        )
    if spheres.shape[1] != 4:
        raise ValueError(
            "Number of columns in spheres ({}) ".format(spheres.shape[1])
            + "not equal to 6"
        )
    # Create the array to store the result
    result = np.zeros(coordinates[0].size, dtype="float64")

    # Compute magnetic field
    jit_kernel(coordinates,spheres,kernels[field],result)
    result *= (MAGNETIC_PERM/(4*np.pi))
    # Convert from T to nanoTesla
    if field in ["phi_xx","phi_xy","phi_xz","phi_yy","phi_yz","phi_zz"]:
        result *= 1e9
    return result

@jit(nopython=True)
def jit_kernel(coordinates,spheres,kernel,out):
    """
    Compute magnetic field at the observation points
    """

    # Iterate over coordinates
    for l in range(coordinates[0].size):
        # Iterate over spheres:
        for m in range(spheres.shape[0]):
            Y = spheres[m,0] - coordinates[0,l]
            X = spheres[m,1] - coordinates[1,l]
            Z = spheres[m,2] - coordinates[2,l]
            r3 = spheres[m,3]*spheres[m,3]*spheres[m,3]
            Volume = (4/3)*np.pi*r3
            out[l] += (Volume*kernel(Y,X,Z))

@jit(nopython=True)
def phi_xx(Y, X, Z):
    """
    Kernel xx for second derivative of the potential generated by a sphere
    """
    radius = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    r2 = radius*radius
    r5 = r2*r2*radius
    kernel = (3*X**2 - r2)/r5
    return kernel

@jit(nopython=True)
def phi_yy(Y, X, Z):
    """
    Kernel yy for second derivative of the potential generated by a sphere
    """
    radius = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    r2 = radius*radius
    r5 = r2*r2*radius
    kernel = (3*Y**2 - r2)/r5
    return kernel

@jit(nopython=True)
def phi_zz(Y, X, Z):
    """
    Kernel zz for second derivative of the potential generated by a sphere
    """
    radius = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    r2 = radius*radius
    r5 = r2*r2*radius
    kernel = (3*Z**2 - r2)/r5
    return kernel

@jit(nopython=True)
def phi_xy(Y, X, Z):
    """
    Kernel xy for second derivative of the potential generated by a sphere
    """
    radius = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    r2 = radius*radius
    r5 = r2*r2*radius
    kernel = (3*X*Y)/r5
    return kernel

@jit(nopython=True)
def phi_xz(Y, X, Z):
    """
    Kernel xz for second derivative of the potential generated by a sphere
    """
    radius = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    r2 = radius*radius
    r5 = r2*r2*radius
    kernel = (3*X*Z)/r5
    return kernel

@jit(nopython=True)
def phi_yz(Y, X, Z):
    """
    Kernel yz for second derivative of the potential generated by a sphere
    """
    radius = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    r2 = radius*radius
    r5 = r2*r2*radius
    kernel = (3*Y*Z)/r5
    return kernel

def sensitivity(coordinates,spheres,main_field):
    '''
    Calculating the sensitivity matrix based on Oliveira Jr et al [2015]
    '''
    
    N = coordinates[0].size
    M = 3
    
    I0,D0 = main_field
    j0x = np.cos(np.deg2rad(I0))*np.cos(np.deg2rad(D0))
    j0y = np.cos(np.deg2rad(I0))*np.sin(np.deg2rad(D0))
    j0z = np.sin(np.deg2rad(I0))
    
    phi_xx = kernel(coordinates,spheres,field='phi_xx')
    phi_xy = kernel(coordinates,spheres,field='phi_xy')
    phi_xz = kernel(coordinates,spheres,field='phi_xz')
    phi_yy = kernel(coordinates,spheres,field='phi_yy')
    phi_yz = kernel(coordinates,spheres,field='phi_yz')
    phi_zz = kernel(coordinates,spheres,field='phi_zz')
    
    A = np.empty((N,M))
    A[:,0] = j0x*phi_xx + j0y*phi_xy + j0z*phi_xz
    A[:,1] = j0x*phi_xy + j0y*phi_yy + j0z*phi_yz
    A[:,2] = j0x*phi_xz + j0y*phi_yz + j0z*phi_zz
    
    return A
