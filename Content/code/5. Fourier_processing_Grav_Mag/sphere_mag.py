'''
This code presents an approach for implementing the gravitational field
produced by a sphere by using the analytical formulas.

References

'''

import numpy as np
from numba import jit


#: The magnetic permeability of free space in Henry*m^{-1}
MAGNETIC_PERM = 0.000001256

def magnetics(coordinates,spheres,intensities,directions,field):
    """
    Computing the magnetic field effect generated by a sphere.
    """

    kernels = {"b_z": kernel_b_z,
               "b_x": kernel_b_x,
               "b_y": kernel_b_y}

    # Checking input field
    if field not in kernels:
        raise ValueError("Magnetic field {} not recognized".format(field))

    # Checking input parameters
    if coordinates.ndim != 2:
        raise ValueError(
            "coordinates ndim ({}) ".format(coordinates.ndim)
            + "not equal to 2"
        )
    if coordinates.shape[0] != 3:
        raise ValueError(
            "Number of lines in coordinates ({}) ".format(coordinates.shape[0])
            + "not equal to 3"
        )
    if spheres.ndim != 2:
        raise ValueError(
            "prisms ndim ({}) ".format(spheres.ndim)
            + "not equal to 2"
        )
    if spheres.shape[1] != 4:
        raise ValueError(
            "Number of columns in spheres ({}) ".format(spheres.shape[1])
            + "not equal to 6"
        )
    if intensities.ndim != 1:
        raise ValueError(
            "intensities ndim ({}) ".format(intensities.ndim)
            + "not equal to 1"
        )
    if intensities.size != spheres.shape[0]:
        raise ValueError(
            "Number of elements in intensities ({}) ".format(intensities.size)
            + "mismatch the number of prisms ({})".format(spheres.shape[0])
        )


    # Create the array to store the result
    result = np.zeros(coordinates[0].size, dtype="float64")

    # Compute magnetic field
    jit_magnetic(coordinates,spheres,intensities,directions,kernels[field],result)
    result *= (MAGNETIC_PERM/(4*np.pi))
    # Convert from T to nanoTesla
    if field in ["b_z","b_x","b_y"]:
        result *= 1e9
    return result

@jit(nopython=True)
def jit_magnetic(coordinates,spheres,intensities,directions,kernel,out):
    """
    Compute magnetic field at the observation points
    """

    # Iterate over coordinates
    for l in range(coordinates[0].size):
        # Iterate over spheres:
        for m in range(spheres.shape[0]):
            Y = spheres[m,0] - coordinates[0,l]
            X = spheres[m,1] - coordinates[1,l]
            Z = spheres[m,2] - coordinates[2,l]
            r3 = spheres[m,3]*spheres[m,3]*spheres[m,3]
            Volume = (4/3)*np.pi*r3
            out[l] += (intensities[m]*Volume*kernel(Y,X,Z,directions[m]))

@jit(nopython=True)
def kernel_xx(Y, X, Z):
    """
    Kernel xx for second derivative of the potential generated by a sphere
    """
    radius = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    r2 = radius*radius
    r5 = r2*r2*radius
    kernel = (3*X**2 - r2)/r5
    return kernel

@jit(nopython=True)
def kernel_yy(Y, X, Z):
    """
    Kernel yy for second derivative of the potential generated by a sphere
    """
    radius = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    r2 = radius*radius
    r5 = r2*r2*radius
    kernel = (3*Y**2 - r2)/r5
    return kernel

@jit(nopython=True)
def kernel_zz(Y, X, Z):
    """
    Kernel zz for second derivative of the potential generated by a sphere
    """
    radius = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    r2 = radius*radius
    r5 = r2*r2*radius
    kernel = (3*Z**2 - r2)/r5
    return kernel

@jit(nopython=True)
def kernel_xy(Y, X, Z):
    """
    Kernel xy for second derivative of the potential generated by a sphere
    """
    radius = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    r2 = radius*radius
    r5 = r2*r2*radius
    kernel = (3*X*Y)/r5
    return kernel

@jit(nopython=True)
def kernel_xz(Y, X, Z):
    """
    Kernel xz for second derivative of the potential generated by a sphere
    """
    radius = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    r2 = radius*radius
    r5 = r2*r2*radius
    kernel = (3*X*Z)/r5
    return kernel

@jit(nopython=True)
def kernel_yz(Y, X, Z):
    """
    Kernel yz for second derivative of the potential generated by a sphere
    """
    radius = np.sqrt(Y ** 2 + X ** 2 + Z ** 2)
    r2 = radius*radius
    r5 = r2*r2*radius
    kernel = (3*Y*Z)/r5
    return kernel


@jit(nopython=True)
def kernel_b_z(Y, X, Z,direction):
    """
    Vertical component of the magnetic field generated by a sphere
    """

    inclination,declination = direction
    jx = np.cos(np.deg2rad(inclination))*np.cos(np.deg2rad(declination))
    jy = np.cos(np.deg2rad(inclination))*np.sin(np.deg2rad(declination))
    jz = np.sin(np.deg2rad(inclination))

    kernel = jx*kernel_xz(Y,X,Z) + jy*kernel_yz(Y,X,Z) + jz*kernel_zz(Y,X,Z)
    return kernel

@jit(nopython=True)
def kernel_b_x(Y, X, Z,direction):
    """
    Computing x component of the magnetic field generated by a sphere
    """
    inclination,declination = direction
    jx = np.cos(np.deg2rad(inclination))*np.cos(np.deg2rad(declination))
    jy = np.cos(np.deg2rad(inclination))*np.sin(np.deg2rad(declination))
    jz = np.sin(np.deg2rad(inclination))

    kernel = jx*kernel_xx(Y,X,Z) + jy*kernel_xy(Y,X,Z) + jz*kernel_xz(Y,X,Z)
    return kernel

@jit(nopython=True)
def kernel_b_y(Y, X, Z,direction):
    """
    Computing y component of the magnetic field generated by a sphere
    """
    inclination,declination = direction
    jx = np.cos(np.deg2rad(inclination))*np.cos(np.deg2rad(declination))
    jy = np.cos(np.deg2rad(inclination))*np.sin(np.deg2rad(declination))
    jz = np.sin(np.deg2rad(inclination))

    kernel = jx*kernel_xy(Y,X,Z) + jy*kernel_yy(Y,X,Z) + jz*kernel_yz(Y,X,Z)
    return kernel
